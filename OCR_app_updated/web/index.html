<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OCR Engine</title>
  <style>
    *{box-sizing:border-box}
    body{font-family:'Segoe UI',system-ui,sans-serif;margin:0;min-height:100vh;
      background:linear-gradient(145deg,#1a1b26,#16161e);color:#a9b1d6;
      display:flex;flex-direction:column;align-items:center;padding:1.5rem 1rem}
    h1{font-size:1.6rem;font-weight:600;color:#c0caf5;margin:0 0 .3rem}
    .sub{font-size:.85rem;opacity:.7;margin-bottom:1.5rem}
    .card{background:rgba(36,40,59,.6);border:1px solid rgba(99,108,144,.3);
      border-radius:12px;padding:1.25rem;max-width:1100px;width:100%;margin-bottom:1rem}
    .card-title{font-size:.85rem;font-weight:600;color:#7aa2f7;margin-bottom:.75rem;
      text-transform:uppercase;letter-spacing:.05em;display:flex;align-items:center;gap:.5rem}
    .card-title .badge{font-size:.7rem;padding:.15rem .4rem;border-radius:4px;
      background:rgba(122,162,247,.15);color:#7aa2f7}
    .card-title .badge-active{background:rgba(224,175,104,.2);color:#e0af68}

    /* Dropzone */
    .dropzone{border:2px dashed rgba(99,108,144,.5);border-radius:10px;padding:1.5rem;
      text-align:center;cursor:pointer;transition:border-color .2s,background .2s;margin-bottom:.75rem}
    .dropzone:hover,.dropzone.dragover{border-color:#7aa2f7;background:rgba(122,162,247,.08)}
    .dropzone input{display:none}
    .dropzone img{max-width:100%;max-height:200px;border-radius:6px;margin-top:.5rem;display:block;margin:0 auto}

    /* Options row */
    .options{display:flex;align-items:center;gap:.75rem;margin-bottom:.75rem;flex-wrap:wrap}
    .options label{font-size:.85rem;color:#a9b1d6}
    .options select{background:rgba(36,40,59,.8);border:1px solid rgba(99,108,144,.4);
      border-radius:6px;color:#c0caf5;padding:.35rem .6rem;font-size:.85rem;cursor:pointer}

    /* Buttons */
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:.3rem;
      padding:.45rem .9rem;border-radius:6px;font-size:.8rem;font-weight:600;
      cursor:pointer;border:none;transition:opacity .15s}
    .btn:hover{opacity:.85}
    .btn-primary{background:#7aa2f7;color:#1a1b26;width:100%;padding:.6rem;font-size:.9rem}
    .btn-primary:hover{background:#89b4fa}
    .btn-primary:disabled{background:#565f89;color:#a9b1d6;cursor:not-allowed;opacity:1}
    .btn-cancel{background:#f7768e;color:#fff;font-size:.7rem;padding:.25rem .5rem}
    .btn-cancel:hover{background:#ff99a8}
    .btn-copy{background:#9ece6a;color:#1a1b26;margin-top:.5rem}
    .btn-view{background:rgba(122,162,247,.2);color:#7aa2f7;font-size:.7rem;padding:.25rem .5rem}
    .btn-remove{background:rgba(99,108,144,.2);color:#565f89;font-size:.7rem;padding:.2rem .4rem}

    /* Status & progress */
    .status{font-size:.8rem;margin-top:.5rem;min-height:1.2rem}
    .status.ok{color:#9ece6a} .status.err{color:#f7768e} .status.warn{color:#e0af68}
    .progress-wrap{margin-top:.4rem;display:none}
    .progress-bar{height:6px;background:rgba(187,154,247,.15);border-radius:3px;overflow:hidden}
    .progress-bar .fill{height:100%;background:#bb9af7;border-radius:3px;transition:width .3s}
    .progress-text{font-size:.75rem;color:#bb9af7;margin-top:.2rem}

    /* Result area */
    .content-area{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-top:.75rem}
    @media(max-width:700px){.content-area{grid-template-columns:1fr}}
    .panel{background:rgba(22,22,30,.6);border-radius:8px;padding:.6rem;
      border:1px solid rgba(99,108,144,.25)}
    .panel-title{font-size:.75rem;font-weight:600;color:#7aa2f7;margin-bottom:.4rem;
      text-transform:uppercase;letter-spacing:.04em}
    .panel img{width:100%;max-height:400px;object-fit:contain;border-radius:4px;display:block}
    .result-text{background:rgba(15,15,20,.8);border:1px solid rgba(99,108,144,.2);
      border-radius:6px;padding:.75rem;color:#c0caf5;font-family:Consolas,'Courier New',monospace;
      font-size:.8rem;line-height:1.5;white-space:pre-wrap;word-break:break-word;
      min-height:80px;max-height:400px;overflow-y:auto}

    /* Task queue */
    .task-list{max-height:320px;overflow-y:auto}
    .task-row{display:flex;align-items:center;gap:.5rem;padding:.45rem .6rem;
      border-radius:6px;margin-bottom:3px;font-size:.78rem;
      background:rgba(22,22,30,.4);border:1px solid rgba(99,108,144,.1);
      transition:background .15s}
    .task-row:hover{background:rgba(22,22,30,.7)}
    .task-row .dot{width:8px;height:8px;border-radius:50%;flex-shrink:0}
    .dot-queued{background:#e0af68} .dot-processing{background:#7aa2f7;animation:pulse 1s infinite}
    .dot-done{background:#9ece6a} .dot-error{background:#f7768e}
    .dot-cancelled{background:#565f89} .dot-timeout{background:#ff9e64}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.4}}
    .task-row .info{flex:1;min-width:0}
    .task-row .info .label{color:#c0caf5;font-weight:500}
    .task-row .info .meta{color:#565f89;font-size:.7rem}
    .task-row .info .msg{color:#7aa2f7;font-size:.68rem;opacity:.8}
    .task-row .mini-bar{width:70px;height:4px;background:rgba(187,154,247,.15);
      border-radius:2px;overflow:hidden;flex-shrink:0}
    .task-row .mini-bar .fill{height:100%;background:#bb9af7;border-radius:2px;transition:width .3s}
    .task-row .actions{display:flex;gap:.3rem;flex-shrink:0}
    .empty-queue{text-align:center;padding:1rem;color:#565f89;font-size:.8rem}

    /* Log viewer */
    .log-toggle{cursor:pointer;user-select:none;font-size:.8rem;color:#565f89}
    .log-toggle:hover{color:#7aa2f7}
    .log-area{background:rgba(10,10,15,.8);border:1px solid rgba(99,108,144,.15);
      border-radius:6px;padding:.5rem;font-family:Consolas,monospace;font-size:.7rem;
      line-height:1.4;max-height:220px;overflow-y:auto;color:#565f89;display:none;margin-top:.5rem}
    .log-area .log-info{color:#a9b1d6} .log-area .log-warn{color:#e0af68}
    .log-area .log-error{color:#f7768e} .log-area .log-ts{color:#565f89;margin-right:.5rem}

    /* GPU badge */
    .gpu-badge{display:inline-block;font-size:.7rem;padding:.15rem .4rem;border-radius:4px;
      background:rgba(122,162,247,.15);color:#7aa2f7;margin-left:.4rem}
  </style>
</head>
<body>
  <h1>OCR Engine <span class="gpu-badge" id="gpuBadge" style="display:none"></span></h1>
  <p class="sub">Upload an image, choose a task, extract text.</p>

  <!-- Upload & Run -->
  <div class="card">
    <div class="dropzone" id="dropzone">
      <input type="file" id="file" accept="image/*">
      <p>Drop an image here or click to choose</p>
    </div>
    <div class="options" id="options" style="display:none">
      <label for="task">Task:</label>
      <select id="task">
        <option value="ocr">OCR (general text)</option>
        <option value="table">Table recognition</option>
        <option value="formula">Formula recognition</option>
        <option value="chart">Chart recognition</option>
        <option value="spotting">Text spotting</option>
        <option value="seal">Seal / stamp</option>
      </select>
    </div>
    <button type="button" id="run" class="btn btn-primary" disabled>Run OCR</button>
    <div class="status" id="status"></div>
    <div class="progress-wrap" id="progressWrap">
      <div class="progress-bar"><div class="fill" id="progressFill" style="width:0%"></div></div>
      <div class="progress-text" id="progressText"></div>
    </div>
  </div>

  <!-- Result -->
  <div class="card" id="resultCard" style="display:none">
    <div class="card-title">Result</div>
    <div class="content-area">
      <div class="panel">
        <div class="panel-title">Input</div>
        <img id="previewImg" alt="Input">
      </div>
      <div class="panel">
        <div class="panel-title">OCR Output</div>
        <div class="result-text" id="resultText"></div>
        <button type="button" class="btn btn-copy" id="copyBtn">Copy to clipboard</button>
      </div>
    </div>
  </div>

  <!-- Task Queue -->
  <div class="card">
    <div class="card-title">
      Task Queue
      <span class="badge" id="queueCount">0</span>
      <span class="badge badge-active" id="activeCount" style="display:none"></span>
    </div>
    <div class="task-list" id="taskList">
      <div class="empty-queue">No tasks yet.</div>
    </div>
  </div>

  <!-- Logs -->
  <div class="card">
    <div class="card-title">
      <span class="log-toggle" id="logToggle">Server Logs [click to toggle]</span>
    </div>
    <div class="log-area" id="logArea"></div>
  </div>

<script>
const API = '';
const $ = id => document.getElementById(id);
const dropzone = $('dropzone'), fileInput = $('file'), runBtn = $('run');
const statusEl = $('status'), progressWrap = $('progressWrap');
const progressFill = $('progressFill'), progressText = $('progressText');
const optionsEl = $('options'), taskSelect = $('task');
const resultCard = $('resultCard'), previewImg = $('previewImg');
const resultText = $('resultText'), copyBtn = $('copyBtn');
const gpuBadge = $('gpuBadge'), taskListEl = $('taskList');
const queueCount = $('queueCount'), activeCountEl = $('activeCount');
const logToggle = $('logToggle'), logArea = $('logArea');

let currentPath = null, currentDataUrl = null;
// FIX: track active task ID and a version counter to prevent stale poll updates
let activeTaskId = null, pollGeneration = 0;

// =====================================================================
// Drag & drop
// =====================================================================
dropzone.addEventListener('click', () => fileInput.click());
dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.classList.add('dragover'); });
dropzone.addEventListener('dragleave', () => dropzone.classList.remove('dragover'));
dropzone.addEventListener('drop', e => {
  e.preventDefault(); dropzone.classList.remove('dragover');
  const f = e.dataTransfer.files[0];
  if (f && f.type.startsWith('image/')) handleFile(f);
});
fileInput.addEventListener('change', () => {
  if (fileInput.files[0]) handleFile(fileInput.files[0]);
});

function setStatus(msg, type) {
  // type: 'ok' | 'err' | 'warn' | undefined
  statusEl.textContent = msg;
  statusEl.className = 'status' + (type ? ' ' + type : '');
}

function setProgress(pct, msg) {
  progressWrap.style.display = 'block';
  progressFill.style.width = Math.min(100, pct) + '%';
  progressText.textContent = msg || (Math.round(pct) + '%');
}

function hideProgress() { progressWrap.style.display = 'none'; }

function handleFile(file) {
  // Check file size client-side (50 MB limit)
  if (file.size > 50 * 1024 * 1024) {
    setStatus('File too large (max 50 MB).', 'err');
    return;
  }
  const reader = new FileReader();
  reader.onload = () => {
    currentDataUrl = reader.result;
    dropzone.innerHTML = '<input type="file" id="file" accept="image/*">' +
      '<p style="margin:0 0 .3rem;font-size:.75rem;color:#565f89">Click or drop to change</p>' +
      '<img src="' + reader.result + '" alt="Preview">';
    $('file').addEventListener('change', () => {
      if ($('file').files[0]) handleFile($('file').files[0]);
    });
    optionsEl.style.display = 'flex';
    currentPath = null; runBtn.disabled = true;
    setStatus('Uploading...', 'warn');
    const fd = new FormData(); fd.append('file', file);
    fetch(API + '/api/upload', { method: 'POST', body: fd })
      .then(r => r.json()).then(d => {
        if (d.error) throw new Error(d.error);
        currentPath = d.path; runBtn.disabled = false;
        setStatus('Ready. Choose a task and click "Run OCR".', 'ok');
      }).catch(e => setStatus('Upload failed: ' + e.message, 'err'));
  };
  reader.readAsDataURL(file);
}

// =====================================================================
// Run OCR
// =====================================================================
runBtn.addEventListener('click', () => {
  if (!currentPath) return;
  const taskType = taskSelect.value;
  setStatus('Submitting...', 'warn');
  setProgress(0, 'Queued...');

  fetch(API + '/api/run', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ image_path: currentPath, task: taskType })
  }).then(r => r.json().then(d => ({ ok: r.ok, d })))
    .then(({ ok, d }) => {
      if (!ok) throw new Error(d.error || 'Failed to create task');
      if (!d.task_id) throw new Error('No task_id in response');
      activeTaskId = d.task_id;
      const pos = d.queue_position || 0;
      setStatus(pos > 1 ? 'Queued (position #' + pos + ').' : 'Task queued.', 'ok');
      startPollActive(d.task_id);
      refreshTasks();
    }).catch(e => { setStatus('Error: ' + e.message, 'err'); hideProgress(); });
});

// =====================================================================
// Poll active task (FIX: generation counter prevents stale updates)
// =====================================================================
function startPollActive(tid) {
  pollGeneration++;  // increment so any previous poll loop stops
  const myGen = pollGeneration;
  const dataUrl = currentDataUrl;  // capture the image at submit time

  const tick = () => {
    // STOP if a newer task was submitted (stale poll)
    if (myGen !== pollGeneration) return;

    fetch(API + '/api/status/' + encodeURIComponent(tid))
      .then(r => r.json())
      .then(d => {
        if (myGen !== pollGeneration) return;  // double-check after await

        const st = (d.status || '').toUpperCase();
        const pct = (d.progress || 0) * 100;
        const msg = d.message || st;

        setProgress(pct, msg + '  (' + Math.round(pct) + '%)');

        if (st === 'DONE') {
          hideProgress();
          setStatus(d.message || 'Done.', 'ok');
          previewImg.src = dataUrl || '';
          resultText.textContent = d.result || '(empty)';
          resultCard.style.display = 'block';
          refreshTasks();
          return;
        }
        if (st === 'ERROR') {
          hideProgress();
          setStatus('Error: ' + (d.error || d.message || 'Unknown'), 'err');
          refreshTasks();
          return;
        }
        if (st === 'CANCELLED') {
          hideProgress();
          setStatus(d.message || 'Cancelled.', 'warn');
          refreshTasks();
          return;
        }
        if (st === 'TIMEOUT') {
          hideProgress();
          setStatus(d.message || 'Task timed out.', 'err');
          refreshTasks();
          return;
        }
        // Still running - poll again
        setTimeout(tick, 800);
      })
      .catch(e => {
        if (myGen !== pollGeneration) return;
        setStatus('Poll error: ' + e.message, 'err');
        hideProgress();
      });
  };
  tick();
}

// =====================================================================
// Cancel task
// =====================================================================
function cancelTask(tid) {
  fetch(API + '/api/cancel', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ task_id: tid })
  }).then(r => r.json()).then(d => {
    if (d.error && !d.message) setStatus('Cancel failed: ' + d.error, 'err');
    refreshTasks();
  }).catch(() => refreshTasks());
}

// =====================================================================
// Remove finished task
// =====================================================================
function removeTask(tid) {
  fetch(API + '/api/tasks/' + encodeURIComponent(tid), { method: 'DELETE' })
    .then(() => refreshTasks()).catch(() => refreshTasks());
}

// =====================================================================
// View completed result (FIX: fetch via API to avoid XSS from inline JSON)
// =====================================================================
function viewResult(tid) {
  setStatus('Loading result...', 'warn');
  fetch(API + '/api/status/' + encodeURIComponent(tid))
    .then(r => r.json())
    .then(d => {
      if (d.error && !d.result) {
        setStatus('Could not load result: ' + d.error, 'err');
        return;
      }
      resultText.textContent = d.result || '(empty)';
      resultCard.style.display = 'block';
      resultCard.scrollIntoView({ behavior: 'smooth' });
      setStatus('Showing result for task ' + tid.substring(0, 8) + '.', 'ok');
    })
    .catch(e => setStatus('Failed to load: ' + e.message, 'err'));
}

// =====================================================================
// Refresh task list
// =====================================================================
let _refreshTimer = null;

function refreshTasks() {
  fetch(API + '/api/tasks').then(r => r.json()).then(d => {
    const items = d.tasks || [];
    const activeN = d.active_count || 0;
    queueCount.textContent = items.length;
    if (activeN > 0) {
      activeCountEl.textContent = activeN + ' active';
      activeCountEl.style.display = 'inline-block';
    } else {
      activeCountEl.style.display = 'none';
    }

    if (!items.length) {
      taskListEl.innerHTML = '<div class="empty-queue">No tasks yet. Upload an image and click Run OCR.</div>';
      return;
    }

    const now = Date.now() / 1000;
    let html = '';
    for (const t of items) {
      const st = (t.status || '').toUpperCase();
      const dotClass = st === 'QUEUED' ? 'dot-queued'
        : st === 'PROCESSING' ? 'dot-processing'
        : st === 'DONE' ? 'dot-done'
        : st === 'ERROR' ? 'dot-error'
        : st === 'TIMEOUT' ? 'dot-timeout'
        : 'dot-cancelled';
      const pct = Math.round((t.progress || 0) * 100);
      const label = t.task_label || t.task_type || '?';

      // Time info
      let timeInfo = '';
      if (st === 'DONE' || st === 'ERROR' || st === 'CANCELLED' || st === 'TIMEOUT') {
        // Show duration
        if (t.started_at && t.finished_at) {
          timeInfo = (t.finished_at - t.started_at).toFixed(1) + 's';
        }
        // And how long ago
        if (t.created_at) {
          timeInfo += (timeInfo ? ' - ' : '') + timeSince(t.created_at);
        }
      } else if (st === 'PROCESSING') {
        // Show elapsed time
        if (t.started_at) {
          const elapsed = now - t.started_at;
          timeInfo = 'running ' + elapsed.toFixed(0) + 's';
        }
      } else if (st === 'QUEUED') {
        // Show queue position
        if (t.queue_position != null) {
          timeInfo = 'position #' + (t.queue_position + 1);
        }
        if (t.created_at) {
          const waiting = now - t.created_at;
          timeInfo += (timeInfo ? ', ' : '') + 'waiting ' + waiting.toFixed(0) + 's';
        }
      }

      // Progress message for active tasks
      let msgLine = '';
      if ((st === 'PROCESSING' || st === 'QUEUED') && t.message) {
        msgLine = '<div class="msg">' + escHtml(t.message) + '</div>';
      }

      // Actions
      let actions = '';
      if (st === 'QUEUED' || st === 'PROCESSING') {
        actions = '<button class="btn btn-cancel" onclick="cancelTask(\'' +
          t.task_id + '\')">Cancel</button>';
      } else if (st === 'DONE') {
        // FIX: viewResult now takes task_id and fetches via API (no inline JSON)
        actions = '<button class="btn btn-view" onclick="viewResult(\'' +
          t.task_id + '\')">View</button>' +
          '<button class="btn btn-remove" onclick="removeTask(\'' +
          t.task_id + '\')">x</button>';
      } else {
        actions = '<button class="btn btn-remove" onclick="removeTask(\'' +
          t.task_id + '\')">x</button>';
      }

      html += '<div class="task-row">' +
        '<div class="dot ' + dotClass + '"></div>' +
        '<div class="info">' +
          '<span class="label">' + escHtml(label) + '</span> ' +
          '<span class="meta">' + escHtml(st) +
            (timeInfo ? ' - ' + escHtml(timeInfo) : '') + '</span>' +
          msgLine +
        '</div>' +
        '<div class="mini-bar"><div class="fill" style="width:' + pct + '%"></div></div>' +
        '<div class="actions">' + actions + '</div>' +
        '</div>';
    }
    taskListEl.innerHTML = html;

    // Auto-refresh faster when tasks are active
    const hasActive = items.some(t =>
      t.status === 'QUEUED' || t.status === 'PROCESSING');
    clearTimeout(_refreshTimer);
    if (hasActive) _refreshTimer = setTimeout(refreshTasks, 1200);
  }).catch(() => {});
}

function timeSince(ts) {
  const s = Math.floor(Date.now() / 1000 - ts);
  if (s < 5) return 'just now';
  if (s < 60) return s + 's ago';
  if (s < 3600) return Math.floor(s / 60) + 'm ago';
  return Math.floor(s / 3600) + 'h ago';
}

function escHtml(s) {
  if (typeof s !== 'string') return '';
  return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;').replace(/'/g, '&#39;');
}

// =====================================================================
// Copy button
// =====================================================================
copyBtn.addEventListener('click', () => {
  const t = resultText.textContent;
  if (!t) return;
  navigator.clipboard.writeText(t).then(() => {
    copyBtn.textContent = 'Copied!';
    setTimeout(() => { copyBtn.textContent = 'Copy to clipboard'; }, 1200);
  }).catch(() => {
    // Fallback for older browsers / non-HTTPS
    try {
      const ta = document.createElement('textarea');
      ta.value = t;
      ta.style.position = 'fixed'; ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.select(); document.execCommand('copy');
      document.body.removeChild(ta);
      copyBtn.textContent = 'Copied!';
      setTimeout(() => { copyBtn.textContent = 'Copy to clipboard'; }, 1200);
    } catch (e) {}
  });
});

// =====================================================================
// Log viewer
// =====================================================================
logToggle.addEventListener('click', () => {
  logArea.style.display = logArea.style.display === 'none' ? 'block' : 'none';
  if (logArea.style.display === 'block') refreshLogs();
});

function refreshLogs() {
  fetch(API + '/api/logs').then(r => r.json()).then(d => {
    const logs = d.logs || [];
    let html = '';
    for (const l of logs) {
      const cls = l.level === 'ERROR' ? 'log-error'
        : l.level === 'WARN' ? 'log-warn' : 'log-info';
      html += '<div class="' + cls + '"><span class="log-ts">' +
        escHtml(l.ts) + '</span>' + escHtml(l.msg) + '</div>';
    }
    logArea.innerHTML = html || '<div style="color:#565f89">No logs yet.</div>';
    logArea.scrollTop = logArea.scrollHeight;
  }).catch(() => {});
}

// Poll logs every 3s if panel is open
setInterval(() => { if (logArea.style.display === 'block') refreshLogs(); }, 3000);

// =====================================================================
// Init: health check + start refreshing
// =====================================================================
fetch(API + '/api/health').then(r => r.json()).then(d => {
  if (d.runner !== 'ok') {
    setStatus('Runner not reachable. Make sure the OCR engine is started.', 'err');
  } else {
    if (d.gpu && d.gpu !== 'unknown' && d.gpu !== 'CPU') {
      gpuBadge.textContent = d.gpu;
      gpuBadge.style.display = 'inline-block';
    } else if (d.device === 'cpu') {
      gpuBadge.textContent = 'CPU mode';
      gpuBadge.style.display = 'inline-block';
      gpuBadge.style.background = 'rgba(247,118,142,.15)';
      gpuBadge.style.color = '#f7768e';
    }
  }
}).catch(() => setStatus('Cannot reach server. Is the application running?', 'err'));

refreshTasks();
setInterval(refreshTasks, 5000);
</script>
</body>
</html>
